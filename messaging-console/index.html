<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MeetSafe Messaging Console</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f3f4f6;
    }
    .log-area::-webkit-scrollbar {
      width: 8px;
    }
    .log-area::-webkit-scrollbar-thumb {
      background: #a0aec0;
      border-radius: 10px;
    }
    .button-primary {
      @apply bg-blue-500 text-white px-4 py-2 rounded shadow hover:bg-blue-600 transition-colors;
    }
    .button-secondary {
      @apply bg-gray-300 text-gray-800 px-4 py-2 rounded shadow hover:bg-gray-400 transition-colors;
    }
    .input-field {
      @apply block w-full my-2 p-2 border rounded focus:ring-blue-500 focus:border-blue-500;
    }
  </style>
</head>
<body class="p-6 space-y-8 flex flex-col lg:flex-row lg:space-x-8">
  <div class="lg:w-1/2 space-y-8">
    <h1 class="text-3xl font-bold">MeetSafe Messaging Console (Sender)</h1>

    <!-- Auth UI (Sender) -->
    <div class="bg-white p-4 rounded shadow">
      <h2 class="text-xl font-semibold mb-3">Authentication (Sender)</h2>
      <input id="authEmailSender" type="email" class="input-field" placeholder="Email" value="sender@example.com"/>
      <input id="authPasswordSender" type="password" class="input-field" placeholder="Password" value="password123"/>
      <div class="flex space-x-2 mt-2">
        <button id="signUpBtnSender" class="button-primary bg-blue-500">Sign Up</button>
        <button id="signInBtnSender" class="button-primary bg-green-500">Sign In</button>
        <button id="signOutBtnSender" class="button-primary bg-red-500">Sign Out</button>
      </div>
      <p class="mt-4 text-sm">Current User: <span id="currentUserDisplaySender" class="font-medium">Not authenticated</span><br>User ID: <span id="currentUidDisplaySender" class="font-medium">N/A</span></p>
      <div class="mt-4">
        <label class="inline-flex items-center">
          <input type="checkbox" id="isProUserSender" class="form-checkbox h-5 w-5 text-blue-600 rounded">
          <span class="ml-2 text-gray-700">Simulate Pro User</span>
        </label>
      </div>
    </div>

    <!-- Trusted Contacts Management -->
    <div class="bg-white p-4 rounded shadow">
      <h2 class="text-xl font-semibold mb-3">Trusted Contacts</h2>
      <input id="contactName" class="input-field" placeholder="Contact Name"/>
      <input id="contactEmail" type="email" class="input-field" placeholder="Contact Email (for app)"/>
      <input id="contactPhone" type="tel" class="input-field" placeholder="Contact Phone (for SMS fallback)"/>
      <select id="contactMethod" class="input-field">
        <option value="app">App (Primary)</option>
        <option value="sms">SMS (Primary)</option>
      </select>
      <button id="addContactBtn" class="button-primary bg-purple-500">Add Contact</button>
      <div class="mt-4">
        <h3 class="text-lg font-medium">Your Contacts:</h3>
        <ul id="contactsList" class="list-disc pl-5 text-sm">
          <!-- Contacts will be loaded here -->
        </ul>
      </div>
    </div>

    <!-- Message Sending -->
    <div class="bg-white p-4 rounded shadow">
      <h2 class="text-xl font-semibold mb-3">Send Message</h2>
      <select id="recipientContact" class="input-field">
        <option value="">Select a Contact</option>
        <!-- Contacts will be populated here dynamically -->
      </select>
      <input id="messageContent" class="input-field" placeholder="Message content"/>
      <input id="testRendezvousIdSender" class="input-field" placeholder="Test Rendezvous ID (e.g., 'test-rdv-123')" value="test-rdv-123"/>
      <div class="mt-2">
        <label class="inline-flex items-center mr-4">
          <input type="radio" name="deliverySim" value="success" checked class="form-radio h-4 w-4 text-green-600">
          <span class="ml-2 text-gray-700">Simulate In-App Success</span>
        </label>
        <label class="inline-flex items-center">
          <input type="radio" name="deliverySim" value="failure" class="form-radio h-4 w-4 text-red-600">
          <span class="ml-2 text-gray-700">Simulate In-App Failure (for fallback)</span>
        </label>
      </div>
      <button id="sendMessageBtn" class="button-primary bg-green-600 mt-4">Send Message</button>
    </div>

    <!-- Monitor Log (Sender) -->
    <div>
      <h2 class="text-lg font-semibold mb-2">Sender Monitor Log</h2>
      <div id="monitorLogSender" class="log-area bg-black text-white p-4 h-64 overflow-y-scroll text-sm rounded-lg shadow-inner">Monitoring log...</div>
    </div>
  </div>

  <div class="lg:w-1/2 space-y-8 mt-8 lg:mt-0">
    <h1 class="text-3xl font-bold">MeetSafe Messaging Console (Receiver)</h1>

    <!-- Auth UI (Receiver) -->
    <div class="bg-white p-4 rounded shadow">
      <h2 class="text-xl font-semibold mb-3">Authentication (Receiver)</h2>
      <input id="authEmailReceiver" type="email" class="input-field" placeholder="Email" value="receiver@example.com"/>
      <input id="authPasswordReceiver" type="password" class="input-field" placeholder="Password" value="password123"/>
      <div class="flex space-x-2 mt-2">
        <button id="signUpBtnReceiver" class="button-primary bg-blue-500">Sign Up</button>
        <button id="signInBtnReceiver" class="button-primary bg-green-500">Sign In</button>
        <button id="signOutBtnReceiver" class="button-primary bg-red-500">Sign Out</button>
      </div>
      <p class="mt-4 text-sm">Current User: <span id="currentUserDisplayReceiver" class="font-medium">Not authenticated</span><br>User ID: <span id="currentUidDisplayReceiver" class="font-medium">N/A</span></p>
    </div>

    <!-- Received Messages Log (Receiver) -->
    <div class="bg-white p-4 rounded shadow">
      <h2 class="text-lg font-semibold mb-2">Received Messages Log</h2>
      <input id="testRendezvousIdReceiver" class="input-field" placeholder="Listen to Rendezvous ID (e.g., 'test-rdv-123')" value="test-rdv-123"/>
      <button id="startListeningBtn" class="button-primary bg-blue-600 mt-2">Start Listening for Messages</button>
      <div id="receivedMessagesLog" class="log-area bg-blue-900 text-white p-4 h-64 overflow-y-scroll text-sm rounded-lg shadow-inner mt-4">Waiting for messages...</div>
    </div>

    <!-- Twilio SMS Log (Conceptual) -->
    <div>
      <h2 class="text-lg font-semibold mb-2">Twilio SMS Outbound Log (Conceptual)</h2>
      <div id="twilioSmsLog" class="log-area bg-purple-900 text-white p-4 h-64 overflow-y-scroll text-sm rounded-lg shadow-inner">Simulated Twilio activity...</div>
    </div>
  </div>

  <!-- Upgrade Prompt Modal -->
  <div id="upgradeModal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white p-6 rounded-lg shadow-xl text-center">
      <h3 class="text-xl font-bold mb-4">Upgrade Required!</h3>
      <p class="mb-6">Free users can only send 1 app-to-app message per contact. Please upgrade to Pro for unlimited messaging and SMS fallback.</p>
      <button onclick="document.getElementById('upgradeModal').classList.add('hidden')" class="button-primary bg-blue-500">Got It!</button>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getFirestore, collection, addDoc, updateDoc, doc, query, where, onSnapshot, Timestamp, getDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    // Firebase configuration provided by the Canvas environment
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const defaultFirebaseConfig = {
      apiKey: "AIzaSyAV52Ads-ckhKuGsKvHoYYTrDIqBHMHusQ",
      authDomain: "meetsafe-clean-core.firebaseapp.com",
      projectId: "meetsafe-clean-core",
      storageBucket: "meetsafe-clean-core.firebasestorage.app",
      messagingSenderId: "970833854934",
      appId: "1:970833854934:web:5ae847503baa2c6c552477",
      measurementId: "G-E6LBFE2SEB"
    };
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : defaultFirebaseConfig;

    // Initialize Firebase apps for sender and receiver (if needed, or reuse one)
    // For simplicity in this console, we'll use one app instance and manage two auth states.
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    let currentUserSender = null;
    let currentUserIdSender = null;
    let isProUserSender = false;
    let userContactsSender = [];

    let currentUserReceiver = null;
    let currentUserIdReceiver = null;
    let unsubscribeMessages = null; // To store the unsubscribe function for messages listener

    // Map to track message counts for free users per contact (identifier -> count)
    const freeUserMessageCounts = new Map();

    // --- Log Functions ---
    const logToMonitor = (msg, type = "info", targetLogId = "monitorLogSender") => {
      const el = document.getElementById(targetLogId);
      const time = new Date().toLocaleTimeString("en-AU", { timeZone: "Australia/Brisbane" });
      const line = document.createElement("div");
      let colorClass = "text-gray-300"; // Default
      if (type === "success") colorClass = "text-green-400";
      else if (type === "error") colorClass = "text-red-400";
      else if (type === "warning") colorClass = "text-yellow-400";
      else if (type === "received") colorClass = "text-blue-300";

      line.innerHTML = `<span class="${colorClass}">[${time}] ${msg}</span>`;
      el.appendChild(line);
      el.scrollTop = el.scrollHeight;
    };

    // --- Authentication Logic (Sender) ---
    const initialAuthSender = async () => {
      try {
        if (typeof __initial_auth_token !== 'undefined') {
          await signInWithCustomToken(auth, __initial_auth_token);
          logToMonitor("Sender: Signed in with custom token.", "success", "monitorLogSender");
        } else {
          await signInAnonymously(auth);
          logToMonitor("Sender: Signed in anonymously.", "info", "monitorLogSender");
        }
      } catch (error) {
        logToMonitor(`Sender: Initial authentication error: ${error.message}`, "error", "monitorLogSender");
      }
    };
    initialAuthSender();

    document.getElementById("signUpBtnSender").addEventListener("click", async () => {
      const email = document.getElementById("authEmailSender").value;
      const pw = document.getElementById("authPasswordSender").value;
      try {
        await createUserWithEmailAndPassword(auth, email, pw);
        logToMonitor("Sender: User signed up successfully!", "success", "monitorLogSender");
      } catch (error) {
        logToMonitor(`Sender: Sign up error: ${error.message}`, "error", "monitorLogSender");
      }
    });

    document.getElementById("signInBtnSender").addEventListener("click", async () => {
      const email = document.getElementById("authEmailSender").value;
      const pw = document.getElementById("authPasswordSender").value;
      try {
        await signInWithEmailAndPassword(auth, email, pw);
        logToMonitor("Sender: User signed in successfully!", "success", "monitorLogSender");
      } catch (error) {
        logToMonitor(`Sender: Sign in error: ${error.message}`, "error", "monitorLogSender");
      }
    });

    document.getElementById("signOutBtnSender").addEventListener("click", async () => {
      try {
        await signOut(auth); // Sign out the current user
        logToMonitor("Sender: User signed out.", "info", "monitorLogSender");
        currentUserSender = null;
        currentUserIdSender = null;
        userContactsSender = [];
        renderContacts();
        populateRecipientDropdown();
        freeUserMessageCounts.clear();
      } catch (error) {
        logToMonitor(`Sender: Sign out error: ${error.message}`, "error", "monitorLogSender");
      }
    });

    onAuthStateChanged(auth, (user) => {
      // This listener will fire for any auth state change, so we need to differentiate sender/receiver
      // For simplicity in this single-page console, we'll assume the last signed-in user is the 'sender'
      // unless explicitly handling two separate auth instances.
      // A more robust solution would use two Firebase app instances for true separation.
      currentUserSender = user || null;
      currentUserIdSender = user?.uid || null;
      document.getElementById("currentUserDisplaySender").textContent = user?.email || "Not authenticated";
      document.getElementById("currentUidDisplaySender").textContent = currentUserIdSender || "N/A";

      if (currentUserSender) {
        logToMonitor(`Sender: Authenticated as: ${currentUserSender.email || 'Anonymous'} (UID: ${currentUserSender.uid})`, "info", "monitorLogSender");
        if (currentUserIdSender) {
          const contactsQuery = query(collection(db, `artifacts/${appId}/users/${currentUserIdSender}/contacts`));
          onSnapshot(contactsQuery, (snapshot) => {
            userContactsSender = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            renderContacts();
            populateRecipientDropdown();
            logToMonitor("Sender: Contacts updated.", "info", "monitorLogSender");
          }, (error) => {
            logToMonitor(`Sender: Error fetching contacts: ${error.message}`, "error", "monitorLogSender");
          });
        }
      } else {
        logToMonitor("Sender: Not authenticated.", "info", "monitorLogSender");
      }
    });

    document.getElementById("isProUserSender").addEventListener("change", (e) => {
      isProUserSender = e.target.checked;
      logToMonitor(`Sender: Simulating Pro User: ${isProUserSender}`, "info", "monitorLogSender");
    });

    // --- Authentication Logic (Receiver) ---
    // Note: For a true two-user simulation on one page, you would ideally initialize a second Firebase app instance.
    // For this console, we'll re-use the same 'auth' instance but manage a separate 'currentUserReceiver' state.
    // This means signing in as receiver will sign out the sender, and vice-versa.
    // For testing purposes, you can manually sign in one, then the other, and observe logs.
    document.getElementById("signUpBtnReceiver").addEventListener("click", async () => {
      const email = document.getElementById("authEmailReceiver").value;
      const pw = document.getElementById("authPasswordReceiver").value;
      try {
        await createUserWithEmailAndPassword(auth, email, pw);
        logToMonitor("Receiver: User signed up successfully!", "success", "receivedMessagesLog");
      } catch (error) {
        logToMonitor(`Receiver: Sign up error: ${error.message}`, "error", "receivedMessagesLog");
      }
    });

    document.getElementById("signInBtnReceiver").addEventListener("click", async () => {
      const email = document.getElementById("authEmailReceiver").value;
      const pw = document.getElementById("authPasswordReceiver").value;
      try {
        await signInWithEmailAndPassword(auth, email, pw);
        logToMonitor("Receiver: User signed in successfully!", "success", "receivedMessagesLog");
      } catch (error) {
        logToMonitor(`Receiver: Sign in error: ${error.message}`, "error", "receivedMessagesLog");
      }
    });

    document.getElementById("signOutBtnReceiver").addEventListener("click", async () => {
      try {
        await signOut(auth);
        logToMonitor("Receiver: User signed out.", "info", "receivedMessagesLog");
        currentUserReceiver = null;
        currentUserIdReceiver = null;
        document.getElementById("receivedMessagesLog").innerHTML = "Waiting for messages...";
        if (unsubscribeMessages) {
          unsubscribeMessages(); // Unsubscribe from messages when signing out
          unsubscribeMessages = null;
        }
      } catch (error) {
        logToMonitor(`Receiver: Sign out error: ${error.message}`, "error", "receivedMessagesLog");
      }
    });

    // This onAuthStateChanged listener will update both sender and receiver UIs
    // depending on which user is currently authenticated.
    onAuthStateChanged(auth, (user) => {
      // Update sender side
      currentUserSender = user || null;
      currentUserIdSender = user?.uid || null;
      document.getElementById("currentUserDisplaySender").textContent = user?.email || "Not authenticated";
      document.getElementById("currentUidDisplaySender").textContent = currentUserIdSender || "N/A";

      // Update receiver side
      currentUserReceiver = user || null;
      currentUserIdReceiver = user?.uid || null;
      document.getElementById("currentUserDisplayReceiver").textContent = user?.email || "Not authenticated";
      document.getElementById("currentUidDisplayReceiver").textContent = currentUserIdReceiver || "N/A";

      if (currentUserSender) { // If any user is signed in, update sender contacts
        logToMonitor(`Sender: Authenticated as: ${currentUserSender.email || 'Anonymous'} (UID: ${currentUserSender.uid})`, "info", "monitorLogSender");
        if (currentUserIdSender) {
          const contactsQuery = query(collection(db, `artifacts/${appId}/users/${currentUserIdSender}/contacts`));
          onSnapshot(contactsQuery, (snapshot) => {
            userContactsSender = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            renderContacts();
            populateRecipientDropdown();
            logToMonitor("Sender: Contacts updated.", "info", "monitorLogSender");
          }, (error) => {
            logToMonitor(`Sender: Error fetching contacts: ${error.message}`, "error", "monitorLogSender");
          });
        }
      } else {
        logToMonitor("Sender: Not authenticated.", "info", "monitorLogSender");
      }

      // Receiver message listening is now explicitly triggered by a button click
      // to allow specifying the rendezvous ID.
      if (currentUserReceiver) {
        logToMonitor(`Receiver: Authenticated as: ${currentUserReceiver.email || 'Anonymous'} (UID: ${currentUserReceiver.uid})`, "info", "receivedMessagesLog");
      } else {
        logToMonitor("Receiver: Not authenticated.", "info", "receivedMessagesLog");
        document.getElementById("receivedMessagesLog").innerHTML = "Waiting for messages...";
      }
    });

    // --- Start Listening Button for Receiver ---
    document.getElementById("startListeningBtn").addEventListener("click", () => {
      if (!currentUserReceiver || !currentUserIdReceiver) {
        logToMonitor("Receiver: Please sign in to start listening for messages.", "warning", "receivedMessagesLog");
        return;
      }
      const rendezvousIdToListen = document.getElementById("testRendezvousIdReceiver").value.trim();
      if (!rendezvousIdToListen) {
        logToMonitor("Receiver: Please enter a Rendezvous ID to listen for messages.", "warning", "receivedMessagesLog");
        return;
      }

      // Unsubscribe from previous listener if any
      if (unsubscribeMessages) {
        unsubscribeMessages();
        logToMonitor("Receiver: Stopped listening to previous rendezvous.", "info", "receivedMessagesLog");
      }
      document.getElementById("receivedMessagesLog").innerHTML = "Waiting for messages..."; // Clear previous messages

      // Listen for messages where 'to' field matches the receiver's UID/email
      // and within the specified rendezvous ID.
      // Note: Firestore does not support querying across subcollections without collection group queries
      // and specific indexes. For this console, we assume messages are sent with 'to' as email/phone.
      // The 'where' clause on 'to' will filter messages within the specified rendezvous's 'messages' subcollection.
      const messagesCollectionRef = collection(db, `artifacts/${appId}/messages/${rendezvousIdToListen}/messages`);
      const messagesQuery = query(messagesCollectionRef, where("recipientEmail", "==", currentUserReceiver.email));
      // Alternatively, if you want to match by UID, you'd need the sender to store the recipient's UID.
      // For now, we'll match by recipientEmail as that's what's stored in 'to' for app messages.

      unsubscribeMessages = onSnapshot(messagesQuery, (snapshot) => {
        snapshot.docChanges().forEach(change => {
          const messageData = change.doc.data();
          if (change.type === "added") {
            logToMonitor(`New message from ${messageData.from}: "${messageData.content}" (Method: ${messageData.method})`, "received", "receivedMessagesLog");
            // Optionally, update message status to acknowledged/read
          } else if (change.type === "modified") {
            logToMonitor(`Message updated (ID: ${change.doc.id}): ${JSON.stringify(messageData)}`, "info", "receivedMessagesLog");
          }
        });
      }, (error) => {
        logToMonitor(`Receiver: Error fetching messages: ${error.message}`, "error", "receivedMessagesLog");
      });
      logToMonitor(`Receiver: Started listening for messages in Rendezvous ID: ${rendezvousIdToListen}`, "info", "receivedMessagesLog");
    });


    // --- Contact Management Logic ---
    document.getElementById("addContactBtn").addEventListener("click", async () => {
      if (!currentUserSender || !currentUserIdSender) {
        logToMonitor("Sender: Please sign in to add contacts.", "warning", "monitorLogSender");
        return;
      }
      const name = document.getElementById("contactName").value.trim();
      const email = document.getElementById("contactEmail").value.trim();
      const phone = document.getElementById("contactPhone").value.trim();
      const method = document.getElementById("contactMethod").value; // Primary method

      if (!name || (!email && !phone)) { // Name is required, and at least one identifier
        logToMonitor("Sender: Contact name and at least one identifier (email or phone) cannot be empty.", "warning", "monitorLogSender");
        return;
      }

      try {
        await addDoc(collection(db, `artifacts/${appId}/users/${currentUserIdSender}/contacts`), {
          name,
          email: email || null, // Store email, null if empty
          phoneNumber: phone || null, // Store phone, null if empty
          method, // Primary method (app or sms)
          createdAt: Timestamp.now(),
          userId: currentUserIdSender
        });
        logToMonitor(`Sender: Contact '${name}' added successfully.`, "success", "monitorLogSender");
        document.getElementById("contactName").value = "";
        document.getElementById("contactEmail").value = "";
        document.getElementById("contactPhone").value = "";
      } catch (error) {
        logToMonitor(`Sender: Error adding contact: ${error.message}`, "error", "monitorLogSender");
      }
    });

    const renderContacts = () => {
      const listEl = document.getElementById("contactsList");
      listEl.innerHTML = "";
      if (userContactsSender.length === 0) {
        listEl.innerHTML = "<li>No contacts added yet.</li>";
        return;
      }
      userContactsSender.forEach(contact => {
        const li = document.createElement("li");
        let identifierDisplay = [];
        if (contact.email) identifierDisplay.push(`Email: ${contact.email}`);
        if (contact.phoneNumber) identifierDisplay.push(`Phone: ${contact.phoneNumber}`);
        li.textContent = `${contact.name} (${identifierDisplay.join(', ')}) [Primary: ${contact.method}]`;
        listEl.appendChild(li);
      });
    };

    const populateRecipientDropdown = () => {
      const selectEl = document.getElementById("recipientContact");
      selectEl.innerHTML = '<option value="">Select a Contact</option>';
      userContactsSender.forEach(contact => {
        const option = document.createElement("option");
        option.value = contact.id;
        let identifierDisplay = [];
        if (contact.email) identifierDisplay.push(contact.email);
        if (contact.phoneNumber) identifierDisplay.push(contact.phoneNumber);
        option.textContent = `${contact.name} (${identifierDisplay.join(' / ')})`;
        selectEl.appendChild(option);
      });
    };

    // --- Messaging Logic ---
    document.getElementById("sendMessageBtn").addEventListener("click", async () => {
      if (!currentUserSender || !currentUserIdSender) {
        logToMonitor("Sender: Please sign in to send messages.", "warning", "monitorLogSender");
        return;
      }

      const selectedContactId = document.getElementById("recipientContact").value;
      const messageContent = document.getElementById("messageContent").value.trim();
      const testRendezvousId = document.getElementById("testRendezvousIdSender").value.trim(); // Use sender's rendezvous ID
      const simulateInAppSuccess = document.querySelector('input[name="deliverySim"]:checked').value === "success";

      if (!selectedContactId || !messageContent || !testRendezvousId) {
        logToMonitor("Sender: Please select a contact, enter message content, and a test rendezvous ID.", "warning", "monitorLogSender");
        return;
      }

      const recipientContact = userContactsSender.find(c => c.id === selectedContactId);
      if (!recipientContact) {
        logToMonitor("Sender: Selected contact not found.", "error", "monitorLogSender");
        return;
      }

      // Determine the 'to' identifier based on the primary method
      // For app messages, 'to' should be the recipient's email (for now, as UID resolution is not in console)
      // For SMS, it's the phone number.
      let toIdentifier = null;
      if (recipientContact.method === "app") {
          toIdentifier = recipientContact.email;
      } else if (recipientContact.method === "sms") {
          toIdentifier = recipientContact.phoneNumber;
      }

      if (!toIdentifier) {
          logToMonitor(`Sender: Cannot send message. Contact '${recipientContact.name}' does not have a valid ${recipientContact.method} identifier.`, "error", "monitorLogSender");
          return;
      }

      // Free user message limit check (only for app messages)
      if (!isProUserSender && recipientContact.method === "app") {
        const currentCount = freeUserMessageCounts.get(toIdentifier) || 0;
        if (currentCount >= 1) {
          document.getElementById("upgradeModal").classList.remove("hidden");
          logToMonitor("Sender: Free user limit reached for app-to-app message.", "warning", "monitorLogSender");
          return;
        }
      }

      try {
        // Create a new subcollection for messages under the rendezvous ID
        const messagesCollectionRef = collection(db, `artifacts/${appId}/messages/${testRendezvousId}/messages`);
        const messageRef = await addDoc(messagesCollectionRef, {
          to: toIdentifier, // Email for app, Phone for SMS
          from: currentUserIdSender,
          sentAt: Timestamp.now(),
          delivered: false,
          method: recipientContact.method,
          fallback: "none",
          acknowledged: false,
          content: messageContent,
          recipientEmail: recipientContact.email || null, // Store both for clarity
          recipientPhone: recipientContact.phoneNumber || null // Store both for clarity
        });
        logToMonitor(`Sender: Message initiated to ${recipientContact.name} via ${recipientContact.method}. Message ID: ${messageRef.id}`, "info", "monitorLogSender");

        if (recipientContact.method === "app") {
          simulateInAppDelivery(messageRef, simulateInAppSuccess, recipientContact, testRendezvousId);
        } else if (recipientContact.method === "sms") {
          // If primary method is SMS, simulate direct SMS send (no in-app attempt first)
          await updateDoc(messageRef, { delivered: true });
          logToMonitor(`Sender: Direct SMS to ${recipientContact.name} simulated as sent.`, "success", "monitorLogSender");
          // Trigger actual Twilio SMS if it's a direct SMS and a phone number exists
          if (recipientContact.phoneNumber) {
              sendTwilioSms(recipientContact.phoneNumber, messageContent, messageRef.id, "Direct SMS");
          }
        }

        // Increment message count for free users (only for app messages)
        if (!isProUserSender && recipientContact.method === "app") {
            freeUserMessageCounts.set(toIdentifier, (freeUserMessageCounts.get(toIdentifier) || 0) + 1);
            logToMonitor(`Sender: Free user app message count for ${recipientContact.name}: ${freeUserMessageCounts.get(toIdentifier)}`, "info", "monitorLogSender");
        }

      } catch (error) {
        logToMonitor(`Sender: Error sending message: ${error.message}`, "error", "monitorLogSender");
      }
    });

    const simulateInAppDelivery = (messageRef, success, recipientContact, rendezvousId) => {
      const deliveryAttemptTimeout = 5000; // Simulate 5 seconds for initial delivery attempt
      const fallbackCheckTimeout = 10000; // Check for fallback after 10 seconds (instead of 60s for faster testing)

      let delivered = false;

      // Simulate initial delivery attempt
      setTimeout(async () => {
        if (success) {
          delivered = true;
          await updateDoc(messageRef, { delivered: true });
          logToMonitor(`Sender: In-app message to ${recipientContact.name} delivered successfully!`, "success", "monitorLogSender");
        } else {
          logToMonitor(`Sender: In-app message to ${recipientContact.name} failed to deliver immediately.`, "warning", "monitorLogSender");
        }
      }, deliveryAttemptTimeout);

      // Check for fallback after `fallbackCheckTimeout` if not delivered
      setTimeout(async () => {
        if (!delivered) {
          const messageSnap = await getDoc(messageRef);
          const messageData = messageSnap.data();

          if (!messageData.delivered && messageData.method === "app") {
            logToMonitor(`Sender: In-app message to ${recipientContact.name} not confirmed delivered within ${fallbackCheckTimeout / 1000}s. Checking fallback...`, "warning", "monitorLogSender");
            if (isProUserSender) {
              if (recipientContact.phoneNumber) { // Check if phone number is available for SMS fallback
                 logToMonitor(`Sender: SMS fallback initiated for ${recipientContact.name} (Pro User).`, "info", "monitorLogSender");
                 // Trigger actual Twilio SMS
                 sendTwilioSms(recipientContact.phoneNumber, messageData.content, messageRef.id, "Fallback SMS");
                 await updateDoc(messageRef, { fallback: "sms", delivered: true }); // Mark delivered after fallback attempt
                 logToMonitor(`Sender: SMS fallback to ${recipientContact.name}'s phone number triggered.`, "success", "monitorLogSender");
              } else {
                 logToMonitor(`Sender: Cannot fallback to SMS for ${recipientContact.name}: No phone number available.`, "warning", "monitorLogSender");
              }
            } else {
              logToMonitor(`Sender: SMS fallback not available for Free User (${recipientContact.name}).`, "warning", "monitorLogSender");
            }
          }
        }
      }, fallbackCheckTimeout);
    };

    // --- Twilio SMS Function (Conceptual Client-Side) ---
    // In a real application, this would be a fetch to your secure server-side proxy
    const sendTwilioSms = async (toPhoneNumber, messageBody, messageId, type) => {
        logToMonitor(`Twilio: Attempting to send ${type} to ${toPhoneNumber} for message ID: ${messageId}`, "info", "twilioSmsLog");
        // IMPORTANT: Replace this with the actual URL of your server-side Twilio proxy.
        // Your Twilio Account SID and Auth Token should be securely stored on your server-side proxy, NOT here.
        const twilioProxyUrl = "http://127.0.0.1:5000/send-sms"; // This should be your proxy URL

        if (twilioProxyUrl === "http://127.0.0.1:5000/send-sms" && !toPhoneNumber.includes('+')) {
            logToMonitor("Twilio: Warning: Phone number might be invalid for real SMS. Ensure it includes country code (e.g., +61...).", "warning", "twilioSmsLog");
        }


        try {
            const response = await fetch(twilioProxyUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    to: toPhoneNumber,
                    body: messageBody,
                    messageId: messageId // Pass message ID for server-side logging/tracking
                }),
            });

            const result = await response.json();

            if (response.ok) {
                logToMonitor(`Twilio: ${type} sent successfully to ${toPhoneNumber}. Response: ${JSON.stringify(result)}`, "success", "twilioSmsLog");
            } else {
                logToMonitor(`Twilio: Failed to send ${type} to ${toPhoneNumber}. Error: ${result.error || response.statusText}`, "error", "twilioSmsLog");
            }
        } catch (error) {
            logToMonitor(`Twilio: Network or unexpected error sending ${type} to ${toPhoneNumber}: ${error.message}`, "error", "twilioSmsLog");
        }
    };
  </script>
</body>
</html>
