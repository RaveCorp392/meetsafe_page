<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MeetSafe Messaging Console</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f3f4f6;
    }
    .log-area::-webkit-scrollbar {
      width: 8px;
    }
    .log-area::-webkit-scrollbar-thumb {
      background: #a0aec0;
      border-radius: 10px;
    }
    .button-primary {
      @apply bg-blue-500 text-white px-4 py-2 rounded shadow hover:bg-blue-600 transition-colors;
    }
    .button-secondary {
      @apply bg-gray-300 text-gray-800 px-4 py-2 rounded shadow hover:bg-gray-400 transition-colors;
    }
    .input-field {
      @apply block w-full my-2 p-2 border rounded focus:ring-blue-500 focus:border-blue-500;
    }
  </style>
</head>
<body class="p-6 space-y-8">
  <h1 class="text-3xl font-bold">MeetSafe Messaging Console</h1>

  <!-- Auth UI -->
  <div class="bg-white p-4 rounded shadow">
    <h2 class="text-xl font-semibold mb-3">Authentication</h2>
    <input id="authEmail" type="email" class="input-field" placeholder="Email" value="test@example.com"/>
    <input id="authPassword" type="password" class="input-field" placeholder="Password" value="password123"/>
    <div class="flex space-x-2 mt-2">
      <button id="signUpBtn" class="button-primary bg-blue-500">Sign Up</button>
      <button id="signInBtn" class="button-primary bg-green-500">Sign In</button>
      <button id="signOutBtn" class="button-primary bg-red-500">Sign Out</button>
    </div>
    <p class="mt-4 text-sm">Current User: <span id="currentUserDisplay" class="font-medium">Not authenticated</span><br>User ID: <span id="currentUidDisplay" class="font-medium">N/A</span></p>
    <div class="mt-4">
      <label class="inline-flex items-center">
        <input type="checkbox" id="isProUser" class="form-checkbox h-5 w-5 text-blue-600 rounded">
        <span class="ml-2 text-gray-700">Simulate Pro User</span>
      </label>
    </div>
  </div>

  <!-- Trusted Contacts Management -->
  <div class="bg-white p-4 rounded shadow">
    <h2 class="text-xl font-semibold mb-3">Trusted Contacts</h2>
    <input id="contactName" class="input-field" placeholder="Contact Name"/>
    <input id="contactIdentifier" class="input-field" placeholder="Email (for app) or Phone (for SMS)"/>
    <select id="contactMethod" class="input-field">
      <option value="app">App (UID/Email)</option>
      <option value="sms">SMS (Phone Number)</option>
    </select>
    <button id="addContactBtn" class="button-primary bg-purple-500">Add Contact</button>
    <div class="mt-4">
      <h3 class="text-lg font-medium">Your Contacts:</h3>
      <ul id="contactsList" class="list-disc pl-5 text-sm">
        <!-- Contacts will be loaded here -->
      </ul>
    </div>
  </div>

  <!-- Message Sending -->
  <div class="bg-white p-4 rounded shadow">
    <h2 class="text-xl font-semibold mb-3">Send Message</h2>
    <select id="recipientContact" class="input-field">
      <option value="">Select a Contact</option>
      <!-- Contacts will be populated here dynamically -->
    </select>
    <input id="messageContent" class="input-field" placeholder="Message content"/>
    <input id="testRendezvousId" class="input-field" placeholder="Test Rendezvous ID (e.g., 'test-rdv-123')" value="test-rdv-123"/>
    <div class="mt-2">
      <label class="inline-flex items-center mr-4">
        <input type="radio" name="deliverySim" value="success" checked class="form-radio h-4 w-4 text-green-600">
        <span class="ml-2 text-gray-700">Simulate Success</span>
      </label>
      <label class="inline-flex items-center">
        <input type="radio" name="deliverySim" value="failure" class="form-radio h-4 w-4 text-red-600">
        <span class="ml-2 text-gray-700">Simulate Failure (for fallback)</span>
      </label>
    </div>
    <button id="sendMessageBtn" class="button-primary bg-green-600 mt-4">Send Message</button>
  </div>

  <!-- Monitor Log -->
  <div>
    <h2 class="text-lg font-semibold mb-2">Monitor Log</h2>
    <div id="monitorLog" class="log-area bg-black text-white p-4 h-64 overflow-y-scroll text-sm rounded-lg shadow-inner">Monitoring log...</div>
  </div>

  <!-- Upgrade Prompt Modal -->
  <div id="upgradeModal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white p-6 rounded-lg shadow-xl text-center">
      <h3 class="text-xl font-bold mb-4">Upgrade Required!</h3>
      <p class="mb-6">Free users can only send 1 app-to-app message per contact. Please upgrade to Pro for unlimited messaging and SMS fallback.</p>
      <button onclick="document.getElementById('upgradeModal').classList.add('hidden')" class="button-primary bg-blue-500">Got It!</button>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getFirestore, collection, addDoc, updateDoc, doc, query, where, getDocs, onSnapshot, Timestamp, getDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    // Firebase configuration provided by the Canvas environment
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    let currentUser = null;
    let isProUser = false;
    let userContacts = []; // Store contacts for the current user

    // Map to track message counts for free users per contact (identifier -> count)
    const freeUserMessageCounts = new Map();

    const logToMonitor = (msg, type = "info") => {
      const el = document.getElementById("monitorLog");
      const time = new Date().toLocaleTimeString("en-AU", { timeZone: "Australia/Brisbane" });
      const line = document.createElement("div");
      let colorClass = "text-gray-300"; // Default
      if (type === "success") colorClass = "text-green-400";
      else if (type === "error") colorClass = "text-red-400";
      else if (type === "warning") colorClass = "text-yellow-400";

      line.innerHTML = `<span class="${colorClass}">[${time}] ${msg}</span>`;
      el.appendChild(line);
      el.scrollTop = el.scrollHeight;
    };

    // --- Authentication Logic ---
    // Initial sign-in using custom token if available, otherwise anonymously
    const initialAuth = async () => {
      try {
        if (typeof __initial_auth_token !== 'undefined') {
          await signInWithCustomToken(auth, __initial_auth_token);
          logToMonitor("Signed in with custom token.", "success");
        } else {
          await signInAnonymously(auth);
          logToMonitor("Signed in anonymously.", "info");
        }
      } catch (error) {
        logToMonitor(`Initial authentication error: ${error.message}`, "error");
      }
    };
    initialAuth(); // Call immediately on script load

    document.getElementById("signUpBtn").addEventListener("click", async () => {
      const email = document.getElementById("authEmail").value;
      const pw = document.getElementById("authPassword").value;
      try {
        await createUserWithEmailAndPassword(auth, email, pw);
        logToMonitor("User signed up successfully!", "success");
      } catch (error) {
        logToMonitor(`Sign up error: ${error.message}`, "error");
      }
    });

    document.getElementById("signInBtn").addEventListener("click", async () => {
      const email = document.getElementById("authEmail").value;
      const pw = document.getElementById("authPassword").value;
      try {
        await signInWithEmailAndPassword(auth, email, pw);
        logToMonitor("User signed in successfully!", "success");
      } catch (error) {
        logToMonitor(`Sign in error: ${error.message}`, "error");
      }
    });

    document.getElementById("signOutBtn").addEventListener("click", async () => {
      try {
        await signOut(auth);
        logToMonitor("User signed out.", "info");
        userContacts = []; // Clear contacts on sign out
        renderContacts();
        populateRecipientDropdown();
        freeUserMessageCounts.clear(); // Clear message counts
      } catch (error) {
        logToMonitor(`Sign out error: ${error.message}`, "error");
      }
    });

    onAuthStateChanged(auth, (user) => {
      currentUser = user || null;
      document.getElementById("currentUserDisplay").textContent = user?.email || "Not authenticated";
      // Use the authenticated user's UID or a generated one for anonymous users
      const userId = currentUser?.uid || crypto.randomUUID();
      document.getElementById("currentUidDisplay").textContent = userId;

      if (currentUser) {
        logToMonitor(`Authenticated as: ${currentUser.email || 'Anonymous'} (UID: ${currentUser.uid})`, "info");
        // Listen for contacts for the current user
        const contactsQuery = query(collection(db, `artifacts/${appId}/users/${currentUser.uid}/contacts`));
        onSnapshot(contactsQuery, (snapshot) => {
          userContacts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
          renderContacts();
          populateRecipientDropdown();
          logToMonitor("Contacts updated.", "info");
        }, (error) => {
          logToMonitor(`Error fetching contacts: ${error.message}`, "error");
        });
      } else {
        logToMonitor("Not authenticated.", "info");
      }
    });

    // Simulate Pro User status
    document.getElementById("isProUser").addEventListener("change", (e) => {
      isProUser = e.target.checked;
      logToMonitor(`Simulating Pro User: ${isProUser}`, "info");
    });

    // --- Contact Management Logic ---
    document.getElementById("addContactBtn").addEventListener("click", async () => {
      if (!currentUser) {
        logToMonitor("Please sign in to add contacts.", "warning");
        return;
      }
      const name = document.getElementById("contactName").value.trim();
      const identifier = document.getElementById("contactIdentifier").value.trim();
      const method = document.getElementById("contactMethod").value;

      if (!name || !identifier) {
        logToMonitor("Contact name and identifier cannot be empty.", "warning");
        return;
      }

      try {
        await addDoc(collection(db, `artifacts/${appId}/users/${currentUser.uid}/contacts`), {
          name,
          identifier, // This can be email (for app) or phone number (for SMS)
          method,
          createdAt: Timestamp.now()
        });
        logToMonitor(`Contact '${name}' added successfully.`, "success");
        document.getElementById("contactName").value = "";
        document.getElementById("contactIdentifier").value = "";
      } catch (error) {
        logToMonitor(`Error adding contact: ${error.message}`, "error");
      }
    });

    const renderContacts = () => {
      const listEl = document.getElementById("contactsList");
      listEl.innerHTML = ""; // Clear existing list
      if (userContacts.length === 0) {
        listEl.innerHTML = "<li>No contacts added yet.</li>";
        return;
      }
      userContacts.forEach(contact => {
        const li = document.createElement("li");
        li.textContent = `${contact.name} (${contact.identifier}) [${contact.method}]`;
        listEl.appendChild(li);
      });
    };

    const populateRecipientDropdown = () => {
      const selectEl = document.getElementById("recipientContact");
      selectEl.innerHTML = '<option value="">Select a Contact</option>'; // Clear and add default
      userContacts.forEach(contact => {
        const option = document.createElement("option");
        option.value = contact.id; // Store Firestore doc ID
        option.textContent = `${contact.name} (${contact.identifier})`;
        selectEl.appendChild(option);
      });
    };

    // --- Messaging Logic ---
    document.getElementById("sendMessageBtn").addEventListener("click", async () => {
      if (!currentUser) {
        logToMonitor("Please sign in to send messages.", "warning");
        return;
      }

      const selectedContactId = document.getElementById("recipientContact").value;
      const messageContent = document.getElementById("messageContent").value.trim();
      const testRendezvousId = document.getElementById("testRendezvousId").value.trim();
      const simulateSuccess = document.querySelector('input[name="deliverySim"]:checked').value === "success";

      if (!selectedContactId || !messageContent || !testRendezvousId) {
        logToMonitor("Please select a contact, enter message content, and a test rendezvous ID.", "warning");
        return;
      }

      const recipientContact = userContacts.find(c => c.id === selectedContactId);
      if (!recipientContact) {
        logToMonitor("Selected contact not found.", "error");
        return;
      }

      // Free user message limit check
      if (!isProUser && recipientContact.method === "app") {
        const currentCount = freeUserMessageCounts.get(recipientContact.identifier) || 0;
        if (currentCount >= 1) {
          document.getElementById("upgradeModal").classList.remove("hidden");
          logToMonitor("Free user limit reached for app-to-app message.", "warning");
          return;
        }
      }

      try {
        const messageRef = await addDoc(collection(db, `artifacts/${appId}/messages/${testRendezvousId}/messages`), {
          to: recipientContact.identifier, // UID or Phone Number
          from: currentUser.uid,
          sentAt: Timestamp.now(),
          delivered: false, // Will be updated on delivery confirmation
          method: recipientContact.method,
          fallback: "none", // Will be updated if fallback occurs
          acknowledged: false, // For future use, if recipient acknowledges
          content: messageContent
        });
        logToMonitor(`Message sent to ${recipientContact.name} via ${recipientContact.method}. Message ID: ${messageRef.id}`, "info");

        if (recipientContact.method === "app") {
          simulateInAppDelivery(messageRef, simulateSuccess, recipientContact);
        } else if (recipientContact.method === "sms") {
          // SMS is considered "delivered" immediately for this simulation unless it's a fallback
          await updateDoc(messageRef, { delivered: true });
          logToMonitor(`SMS to ${recipientContact.name} simulated as sent.`, "success");
        }

        // Increment message count for free users
        if (!isProUser && recipientContact.method === "app") {
            freeUserMessageCounts.set(recipientContact.identifier, (freeUserMessageCounts.get(recipientContact.identifier) || 0) + 1);
            logToMonitor(`Free user app message count for ${recipientContact.name}: ${freeUserMessageCounts.get(recipientContact.identifier)}`, "info");
        }

      } catch (error) {
        logToMonitor(`Error sending message: ${error.message}`, "error");
      }
    });

    const simulateInAppDelivery = (messageRef, success, recipientContact) => {
      const deliveryTimeout = 5000; // Simulate 5 seconds for delivery attempt
      const fallbackTimeout = 60000; // 60 seconds for fallback check

      let delivered = false;

      // Simulate immediate delivery check
      setTimeout(async () => {
        if (success) {
          delivered = true;
          await updateDoc(messageRef, { delivered: true });
          logToMonitor(`In-app message to ${recipientContact.name} delivered successfully!`, "success");
        } else {
          logToMonitor(`In-app message to ${recipientContact.name} failed to deliver immediately.`, "warning");
        }
      }, deliveryTimeout);

      // Check for fallback after 60 seconds if not delivered
      setTimeout(async () => {
        if (!delivered) {
          const messageSnap = await getDoc(messageRef);
          const messageData = messageSnap.data();

          if (!messageData.delivered && messageData.method === "app") { // Double check if not delivered and was an app message
            logToMonitor(`In-app message to ${recipientContact.name} not confirmed delivered within 60s. Checking fallback...`, "warning");
            if (isProUser) { // Only Pro users have SMS fallback
              // For SMS fallback, we need a phone number. If identifier is email (for app), this is a limitation in simulation.
              // In a real app, you'd resolve the contact's UID to their registered phone number.
              if (recipientContact.method === "app" && recipientContact.identifier.includes('@')) {
                 logToMonitor(`SMS fallback initiated for ${recipientContact.name} (Pro User). Note: Phone number for fallback not available in this simulation.`, "info");
                 // Simulate SMS sending by marking as delivered via fallback
                 await updateDoc(messageRef, { fallback: "sms", delivered: true }); // Mark delivered after fallback
                 logToMonitor(`SMS fallback to ${recipientContact.name}'s phone number (simulated) sent.`, "success");
              } else if (recipientContact.method === "sms") {
                 // This case should ideally not happen as it's already an SMS method, but for robustness:
                 logToMonitor(`SMS fallback not needed for ${recipientContact.name} as method is already SMS.`, "info");
              }
            } else {
              logToMonitor(`SMS fallback not available for Free User (${recipientContact.name}).`, "warning");
            }
          }
        }
      }, fallbackTimeout);
    };

  </script>
</body>
</html>
